# 任务管理文件夹上传功能 - 前端修改说明

## 概述

本次更新为任务管理模块添加了文件夹上传功能，支持一次性上传整个文件夹及其所有子文件和目录结构。

**重要限制**：文件夹上传功能仅支持代码文件类型，不支持图片、视频、音频等非代码文件。系统会在上传前自动验证所有文件的类型，如果包含非代码文件，将拒绝上传并提示具体的不支持文件列表。

## 后端接口说明

### 新增接口：批量上传文件

**接口地址：** `POST /task/file/uploadBatch`

**请求参数：**
- `files` (MultipartFile[]): 文件数组（必需）
- `relativePaths` (String[]): 相对路径数组（可选），与files数组一一对应
- `taskId` (Long): 任务ID（可选）

**响应示例：**
```json
{
  "code": 200,
  "msg": "操作成功",
  "data": [
    {
      "id": 1,
      "taskId": null,
      "name": "App.java",
      "relativePath": "src/main/java/App.java",
      "url": "https://oss.example.com/xxx/xxx.java",
      "size": 1024,
      "type": "text/plain",
      "fileCategory": "input",
      "uploadTime": "2024-01-01T00:00:00.000Z"
    }
  ]
}
```

**错误响应示例（文件类型不符合要求）：**
```json
{
  "code": 500,
  "msg": "上传失败：以下文件不是代码文件类型，仅支持代码文件上传。不支持的文件：image.png、video.mp4。支持的代码文件类型包括：Java、JavaScript、TypeScript、Python、C/C++、C#、Go、Rust、PHP、Ruby、Swift、Kotlin、Scala、HTML/CSS、配置文件、脚本文件、SQL等。"
}
```

## 前端修改方案

### 方案一：使用 webkitdirectory 属性（推荐）

HTML5 提供了 `webkitdirectory` 属性，允许用户选择整个文件夹。

#### 1. HTML 文件选择器修改

```html
<!-- 单文件上传（原有功能保持不变） -->
<input 
  type="file" 
  id="singleFileInput" 
  @change="handleSingleFileChange"
/>

<!-- 文件夹上传（新增功能） -->
<input 
  type="file" 
  id="folderInput" 
  webkitdirectory 
  multiple 
  @change="handleFolderChange"
/>
```

#### 2. Vue 组件修改示例

```vue
<template>
  <div>
    <!-- 单文件上传按钮 -->
    <el-upload
      :action="uploadUrl"
      :data="{ taskId: taskId }"
      :on-success="handleUploadSuccess"
      :before-upload="beforeUpload"
    >
      <el-button type="primary">上传单个文件</el-button>
    </el-upload>

    <!-- 文件夹上传按钮（新增） -->
    <input
      ref="folderInput"
      type="file"
      webkitdirectory
      multiple
      style="display: none"
      @change="handleFolderUpload"
    />
    <el-button type="primary" @click="triggerFolderUpload">
      上传文件夹
    </el-button>

    <!-- 上传进度显示 -->
    <el-progress
      v-if="uploadProgress > 0 && uploadProgress < 100"
      :percentage="uploadProgress"
    ></el-progress>
  </div>
</template>

<script>
export default {
  data() {
    return {
      uploadUrl: '/task/file/upload',
      batchUploadUrl: '/task/file/uploadBatch',
      taskId: null,
      uploadProgress: 0
    }
  },
  methods: {
    // 触发文件夹选择
    triggerFolderUpload() {
      this.$refs.folderInput.click()
    },

    // 处理文件夹上传
    async handleFolderUpload(event) {
      const files = event.target.files
      if (!files || files.length === 0) {
        this.$message.warning('请选择文件夹')
        return
      }

      this.$message.info(`已选择 ${files.length} 个文件，开始上传...`)
      this.uploadProgress = 0

      try {
        // 准备文件数组和相对路径数组
        const fileArray = Array.from(files)
        const relativePaths = []
        
        // 从 File 对象中提取相对路径（webkitRelativePath）
        fileArray.forEach(file => {
          // file.webkitRelativePath 包含文件的相对路径，如 "folder/subfolder/file.txt"
          relativePaths.push(file.webkitRelativePath || file.name)
        })

        // 创建 FormData
        const formData = new FormData()
        fileArray.forEach(file => {
          formData.append('files', file)
        })
        
        // 添加相对路径数组（可选，如果不传，后端会使用文件名作为默认值）
        relativePaths.forEach(path => {
          formData.append('relativePaths', path)
        })
        
        if (this.taskId) {
          formData.append('taskId', this.taskId)
        }

        // 发送请求
        // 注意：使用FormData时，不要手动设置Content-Type，浏览器会自动设置正确的boundary
        const response = await this.$http.post(this.batchUploadUrl, formData, {
          // headers: {
          //   'Content-Type': 'multipart/form-data'  // 不要手动设置，让浏览器自动设置
          // },
          onUploadProgress: (progressEvent) => {
            if (progressEvent.lengthComputable) {
              this.uploadProgress = Math.round(
                (progressEvent.loaded * 100) / progressEvent.total
              )
            }
          }
        })

        if (response.data.code === 200) {
          this.$message.success(`成功上传 ${response.data.data.length} 个文件`)
          this.uploadProgress = 100
          // 刷新文件列表或执行其他回调
          this.$emit('upload-success', response.data.data)
        } else {
          this.$message.error(response.data.msg || '上传失败')
        }
      } catch (error) {
        console.error('文件夹上传失败:', error)
        this.$message.error('上传失败: ' + (error.message || '未知错误'))
      } finally {
        // 清空文件选择器
        event.target.value = ''
        setTimeout(() => {
          this.uploadProgress = 0
        }, 2000)
      }
    },

    // 原有的单文件上传处理（保持不变）
    handleUploadSuccess(response) {
      if (response.code === 200) {
        this.$message.success('文件上传成功')
        this.$emit('upload-success', [response.data])
      }
    },

    beforeUpload(file) {
      // 文件上传前的验证逻辑
      return true
    }
  }
}
</script>
```

### 方案二：使用 Axios 直接调用

```javascript
// 使用 Axios 批量上传
async function uploadFolder(files, taskId) {
  const formData = new FormData()
  
  // 添加所有文件
  Array.from(files).forEach(file => {
    formData.append('files', file)
  })
  
  // 添加相对路径（从 webkitRelativePath 获取）
  Array.from(files).forEach(file => {
    const relativePath = file.webkitRelativePath || file.name
    formData.append('relativePaths', relativePath)
  })
  
  if (taskId) {
    formData.append('taskId', taskId)
  }

  try {
    // 注意：使用FormData时，不要手动设置Content-Type，axios会自动设置正确的boundary
    const response = await axios.post('/task/file/uploadBatch', formData)
    // 如果必须设置headers，请不要包含Content-Type，或设置为undefined
    // const response = await axios.post('/task/file/uploadBatch', formData, {
    //   headers: {
    //     // 'Content-Type': undefined  // 让浏览器自动设置
    //   }
    // })
    
    return response.data
  } catch (error) {
    console.error('上传失败:', error)
    throw error
  }
}
```

## 重要提示

### 1. 相对路径的获取

当使用 `webkitdirectory` 属性选择文件夹时，浏览器会为每个 File 对象自动设置 `webkitRelativePath` 属性，包含文件相对于文件夹根目录的路径。

**示例：**
- 选择的文件夹：`/Users/username/myProject`
- 文件路径：`/Users/username/myProject/src/main/java/App.java`
- `file.webkitRelativePath` 值为：`src/main/java/App.java`

### 2. 支持的代码文件类型

文件夹上传功能仅支持以下代码文件类型：

**编程语言文件：**
- Java: `.java`, `.class`, `.jar`, `.war`, `.ear`
- JavaScript/TypeScript: `.js`, `.jsx`, `.ts`, `.tsx`, `.mjs`, `.cjs`
- Python: `.py`, `.pyc`, `.pyo`, `.pyw`, `.pyd`
- C/C++: `.c`, `.cpp`, `.cc`, `.cxx`, `.h`, `.hpp`, `.hxx`, `.hh`
- C#: `.cs`, `.csx`
- Go: `.go`
- Rust: `.rs`
- PHP: `.php`, `.php3`, `.php4`, `.php5`, `.phtml`
- Ruby: `.rb`, `.rbw`
- Swift: `.swift`
- Kotlin: `.kt`, `.kts`
- Scala: `.scala`, `.sc`

**Web相关：**
- HTML/CSS: `.html`, `.htm`, `.xhtml`, `.css`, `.scss`, `.sass`, `.less`, `.styl`
- Vue: `.vue`

**配置文件：**
- `.json`, `.xml`, `.yml`, `.yaml`, `.properties`, `.ini`, `.conf`, `.config`, `.toml`

**脚本文件：**
- `.sh`, `.bash`, `.zsh`, `.fish`, `.bat`, `.cmd`, `.ps1`, `.psm1`

**数据库：**
- SQL: `.sql`, `.ddl`, `.dml`

**构建和依赖管理：**
- `.gradle`, `.maven`, `.pom`, `.build`, `Makefile`, `CMakeLists.txt`

**其他代码相关：**
- `.md`, `.markdown`, `.txt`, `.log`, `.gitignore`, `Dockerfile`, `.env`
- 数据文件: `.csv`, `.tsv`

**不支持的文件类型：**
- 图片文件（`.jpg`, `.png`, `.gif` 等）
- 视频文件（`.mp4`, `.avi` 等）
- 音频文件（`.mp3`, `.wav` 等）
- Office文档（`.doc`, `.docx`, `.xls`, `.xlsx` 等）
- 压缩文件（`.zip`, `.rar` 等）
- PDF文件（`.pdf`）

### 3. 浏览器兼容性

- **Chrome/Edge**: ✅ 完全支持
- **Firefox**: ✅ 支持（需要 `webkitdirectory` 属性）
- **Safari**: ✅ 支持（需要 `webkitdirectory` 属性）
- **IE**: ❌ 不支持（IE 11 也不支持）

### 4. 文件大小限制

**后端配置的上传大小限制**（已在 `application.yml` 中配置）：
- **单个文件最大**: 500MB
- **总请求大小最大**: 2GB

**注意事项**：
- 如果上传的文件夹总大小超过2GB，会抛出 `MaxUploadSizeExceededException` 异常
- 前端会收到友好的错误提示："上传文件大小超出限制，请减小文件大小后重试。单个文件最大500MB，总大小最大2GB"
- 如需调整限制，请修改 `application.yml` 中的 `spring.servlet.multipart` 配置

### 5. 文件数量限制

对于包含大量文件的文件夹，建议：
- 显示上传进度
- 设置合理的超时时间（建议至少5分钟）
- 考虑分批上传（每次上传一定数量的文件）
- 对于超大文件夹，建议压缩后上传单个压缩文件

### 6. Content-Type 设置注意事项

**重要**：使用 FormData 上传文件时，不要手动设置 `Content-Type: multipart/form-data`，应该让浏览器或axios自动设置。手动设置会导致无法正确设置 boundary 参数，从而出现 `NoResourceFoundException` 错误。

**正确做法**：
```javascript
// ✅ 正确：不设置Content-Type，让浏览器自动设置
const response = await axios.post('/task/file/uploadBatch', formData)

// ❌ 错误：手动设置Content-Type会导致boundary缺失
const response = await axios.post('/task/file/uploadBatch', formData, {
  headers: {
    'Content-Type': 'multipart/form-data'  // 不要这样做！
  }
})
```

### 7. 错误处理

建议在上传过程中捕获并处理以下错误：
- **NoResourceFoundException**: 通常是Content-Type设置问题，确保让浏览器自动设置
- **MaxUploadSizeExceededException**: 文件大小超出限制，提示用户减小文件大小或分批上传
- **文件类型验证失败**: 包含非代码文件，系统会返回详细的不支持文件列表，前端应友好提示用户
- 网络错误
- 超时错误（建议设置较长的超时时间，如5分钟）
- 服务器返回的错误

**错误处理示例**：
```javascript
try {
  const response = await axios.post('/task/file/uploadBatch', formData, {
    timeout: 300000 // 5分钟超时
  })
} catch (error) {
  if (error.response) {
    // 服务器返回的错误
    const message = error.response.data?.msg || error.response.data?.message
    if (message && message.includes('超出限制')) {
      this.$message.error('文件大小超出限制，请减小文件大小或分批上传')
    } else if (message && message.includes('不是代码文件类型')) {
      // 文件类型验证失败，显示详细错误信息
      this.$message.error(message)
      // 或者可以提取不支持的文件列表，单独显示
      const invalidFilesMatch = message.match(/不支持的文件：([^。]+)/)
      if (invalidFilesMatch) {
        const invalidFiles = invalidFilesMatch[1].split('、')
        this.$message.warning(`发现 ${invalidFiles.length} 个非代码文件，请移除后重试`)
      }
    } else {
      this.$message.error(message || '上传失败')
    }
  } else if (error.request) {
    // 请求已发出但没有收到响应（可能是超时）
    this.$message.error('上传超时，请检查网络连接或减小文件大小')
  } else {
    // 其他错误
    this.$message.error('上传失败: ' + error.message)
  }
}
```

## 数据库修改

执行以下 SQL 脚本，添加相对路径字段：

```sql
-- 文件位置：script/sql/update/task_management_file_add_relative_path.sql
ALTER TABLE `task_management_file` 
ADD COLUMN `relative_path` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL 
COMMENT '相对路径（用于文件夹上传，如：src/main/java/App.java）' 
AFTER `name`;

ALTER TABLE `task_management_file` 
ADD INDEX `idx_relative_path`(`relative_path`) USING BTREE;
```

## 测试建议

1. **单文件上传**：确保原有功能正常工作
2. **文件夹上传**：选择包含多个文件和子文件夹的文件夹进行测试
3. **空文件夹**：验证空文件夹的处理
4. **大文件**：测试包含大文件的文件夹上传
5. **路径显示**：验证前端是否正确显示文件的相对路径

## 相关文件

- **后端接口**: `TaskManagementController.uploadFiles()`
- **服务实现**: `TaskManagementFileServiceImpl.uploadFiles()`
- **数据库迁移**: `script/sql/update/task_management_file_add_relative_path.sql`
- **实体类**: `TaskManagementFile` (已添加 `relativePath` 字段)

